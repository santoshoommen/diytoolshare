import { useState, useCallback } from 'react';

/**
 * Custom hook for managing image classification and auto-population
 * 
 * This hook handles the integration between image classification results
 * and form field auto-population in the listing creation flow.
 */

export const useImageClassification = (formApi) => {
  const [classificationHistory, setClassificationHistory] = useState([]);
  const [isAutoPopulating, setIsAutoPopulating] = useState(false);

  /**
   * Handle classification completion
   * @param {Object} result - Classification result from the service
   */
  const handleClassificationComplete = useCallback((result) => {
    // Store classification result in history
    setClassificationHistory(prev => [...prev, {
      timestamp: Date.now(),
      result,
      applied: false
    }]);

    // If confidence is high enough, auto-populate fields
    if (result.isConfident && result.suggestion) {
      autoPopulateFields(result.suggestion);
    }
  }, [formApi]);

  /**
   * Handle user accepting a suggestion
   * @param {Object} suggestion - The accepted suggestion
   */
  const handleSuggestionAccepted = useCallback((suggestion) => {
    setIsAutoPopulating(true);
    
    try {
      autoPopulateFields(suggestion);
      
      // Update history to mark as applied
      setClassificationHistory(prev => 
        prev.map(item => 
          item.timestamp === Math.max(...prev.map(h => h.timestamp))
            ? { ...item, applied: true }
            : item
        )
      );
    } catch (error) {
      console.error('Error auto-populating fields:', error);
    } finally {
      setIsAutoPopulating(false);
    }
  }, [formApi]);

  /**
   * Handle user rejecting a suggestion
   * @param {Object} result - The classification result
   */
  const handleSuggestionRejected = useCallback((result) => {
    // Update history to mark as rejected
    setClassificationHistory(prev => 
      prev.map(item => 
        item.timestamp === Math.max(...prev.map(h => h.timestamp))
          ? { ...item, applied: false, rejected: true }
          : item
      )
    );
  }, []);

  /**
   * Auto-populate form fields based on suggestion
   * @param {Object} suggestion - The tool description suggestion
   */
  const autoPopulateFields = useCallback((suggestion) => {
    if (!formApi || !suggestion) return;

    const { title, description, category, features, safetyNotes } = suggestion;

    // Auto-populate title if empty
    const currentTitle = formApi.getFieldState('title')?.value;
    if (!currentTitle && title) {
      formApi.change('title', title);
    }

    // Auto-populate description if empty
    const currentDescription = formApi.getFieldState('description')?.value;
    if (!currentDescription && description) {
      formApi.change('description', description);
    }

    // Auto-populate category if available and form supports it
    // Note: This depends on your form structure - adjust field names as needed
    if (category) {
      // Example: if you have a category field
      // formApi.change('category', category);
      
      // Or if you have custom listing fields for tool category
      // formApi.change('toolCategory', category);
    }

    // Store additional metadata for potential use
    if (features || safetyNotes) {
      const metadata = {
        features: features || [],
        safetyNotes: safetyNotes || [],
        autoGenerated: true,
        generatedAt: new Date().toISOString()
      };
      
      // Store in a custom field or as part of description
      // This could be used for displaying additional information
      formApi.change('toolMetadata', metadata);
    }
  }, [formApi]);

  /**
   * Get the latest classification result
   * @returns {Object|null} Latest classification result
   */
  const getLatestClassification = useCallback(() => {
    if (classificationHistory.length === 0) return null;
    return classificationHistory[classificationHistory.length - 1];
  }, [classificationHistory]);

  /**
   * Clear classification history
   */
  const clearHistory = useCallback(() => {
    setClassificationHistory([]);
  }, []);

  /**
   * Undo the last auto-population
   */
  const undoLastAutoPopulation = useCallback(() => {
    const latest = getLatestClassification();
    if (latest && latest.applied) {
      // This would require storing the previous values
      // For now, we'll just mark it as undone
      setClassificationHistory(prev => 
        prev.map(item => 
          item.timestamp === latest.timestamp
            ? { ...item, applied: false, undone: true }
            : item
        )
      );
    }
  }, [getLatestClassification]);

  return {
    // State
    classificationHistory,
    isAutoPopulating,
    
    // Actions
    handleClassificationComplete,
    handleSuggestionAccepted,
    handleSuggestionRejected,
    clearHistory,
    undoLastAutoPopulation,
    
    // Getters
    getLatestClassification,
    
    // Computed
    hasClassifications: classificationHistory.length > 0,
    hasAppliedSuggestions: classificationHistory.some(item => item.applied),
    latestClassification: getLatestClassification()
  };
};

export default useImageClassification;
